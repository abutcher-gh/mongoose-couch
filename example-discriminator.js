'use strict';

let mongoose = require('./lib/index');

mongoose.connect('http://localhost', process.env.COUCH_PORT || 5984, {
  cache: process.env.NO_CACHE ? false : true,
});

let NamedEntitySchema = new mongoose.Schema({
   displayName: { type: String },
});
let NamedEntity = mongoose.model('NamedEntity', NamedEntitySchema);

let UserSchema = new mongoose.Schema({
   name: { type: String },
   displayName: { type: String },
   age: { type: Number },
});

let GroupSchema = new mongoose.Schema({
   name: { type: String },
   displayName: { type: String },
   members: [{ type: String, ref: 'NamedEntity' }],
});

let DemoListSchema = new mongoose.Schema({
   displayName: { type: String },
   list: [{ type: String, ref: 'NamedEntity' }],
});

let User = NamedEntity.discriminator('User', UserSchema);
let Group = NamedEntity.discriminator('Group', GroupSchema);
let DemoList = NamedEntity.discriminator('DemoList', DemoListSchema);

let async = require('async');

function ensureIndicies(model, indices, done) {
   model.findById('_design/index', function (err, design) {
      design = design && design._doc || {};
      if (!design.views)
         design.views = {};
      let views = design.views;
      let modified = false;
      for (let index of indices)
         if (!views[index.name] || views[index.name].ver < index.ver) {
            let def = {};
            if (index.map)
               def.map = index.map;
            if (index.reduce)
               def.reduce = index.reduce;
            if (index.ver)
               def.ver = index.ver;
            views[index.name] = def;
            modified = true;
         }
      if (modified)
         model.collection.collection.save('_design/index', design, done);
      else
         done();
   });
}

// Something like this (albeit just the $kind filtering) could be
// generated by mongoose-couch automatically (unless suppressed by
// the client (either completely or per index)).
var Indices = [
   { name: 'displayNames', map: function (doc) { emit(doc.displayName.replace(/\s/g,'').toLowerCase(), doc); }, ver: 1 },
   { name: 'names', map: function (doc) { if (doc['name'] !== undefined) emit(doc.name.toLowerCase(), doc); }, ver: 1 },
   { name: 'users', map: function (doc) { if (doc['$kind'] === 'User') emit(doc.name.toLowerCase(), doc); }, ver: 1 },
   { name: 'groups', map: function (doc) { if (doc['$kind'] === 'Group') emit(doc.name.toLowerCase(), doc); }, ver: 1 },
   { name: 'demolists', map: function (doc) { if (doc['$kind'] === 'DemoList') emit(doc.displayName.replace(/\s/g,'').toLowerCase(), doc); }, ver: 1 },
];

async.series([
   (next) => ensureIndicies(NamedEntity, Indices, next),
   (next) => NamedEntity.find({}).remove(next),
   (next) => {
      async.parallel([
         (done) => new NamedEntity({_id: '100', displayName: 'Just a display name'}).save(done),
         (done) => new User({_id: '101', name: 'bob', displayName: 'Robert the Bruce'}).save(done),
         (done) => new Group({_id: '102', name: 'group1', displayName: 'A group', members: ['100', '101']}).save(done),
         (done) => new DemoList({_id: '103', name: 'list1', displayName: 'A demo list', list: ['101', '102']}).save(done),
         ], next);
   },
   (next) => {
      NamedEntity.findWithView('index/displayNames', {}, (err, docs) => console.log('NamedEntityByDisplayName', err, docs));
      NamedEntity.findWithView('index/names', {}, (err, docs) => console.log('NamedEntityByName', err, docs));
      User.findWithView('index/groups', {}, (err, docs) => console.log('Group', err, docs));
      DemoList.findWithView('index/demolists', {}, (err, docs) => console.log('DemoList', err, docs));
      User.findWithView('index/users', {}, (err, docs) => console.log('User', err, docs));
   },
]);
